#!/usr/bin/gawk -f

BEGIN{
  
  APPNAME ="do"
  
  load()

  test_args()

  if(DEBUG)
    debug("pre-action")
  
  if ((ARGC == 4) && (ARGV[1] == "add"))
    add_node(ARGV[2], ARGV[3])
  if ((ARGC == 4) && (ARGV[1] == "insert"))
    insert_node(ARGV[2], ARGV[3])
  if ((ARGC == 3) && (ARGV[1] == "spin"))
    spin_node(ARGV[2])
  if ((ARGC == 3) && (ARGV[1] == "rm"))
    rm_node(ARGV[2])
  if ((ARGC == 4) && (ARGV[1] == "edit"))
    edit_label(ARGV[2], ARGV[3])

  if(DEBUG)
    debug("post-action")
  
  make_jpg()

  if(DEBUG)
    debug("final")

  write_phy()

  
  exit 0
}

function test_node_is_out(x)  {
  if (U[x] || (x == Root))
    error("'" x "' already in tree")
  
  # fix index, an entry for U[x] was created during test
  delete U[x]
}

function test_node_is_in(x)  {
  if (!U[x] && (x != Root))
    error("'" x "' is not in tree")

  # fix index in case the root was used as a test
  if (x == Root)
    delete U[Root]
}

function load(   i) {

  FS=OFS="|"
  PROCINFO["sorted_in"] = "@ind_str_asc"

  if(ENVIRON["PHYEDIT_FILEBASE"])
    FILEBASE = ENVIRON["PHYEDIT_FILEBASE"]
  else
    FILEBASE = "phy"

  if(ENVIRON["PHYEDIT_DIR"])
    DIR = ENVIRON["PHYEDIT_DIR"]
  else
    DIR = "."
  
  if (system("test -f " DIR "/" FILEBASE ".fy" ))
    error("'" DIR "/" FILEBASE ".fy' is not a file")
  
  # read tree
  while ((getline < (DIR "/" FILEBASE ".fy")) > 0) {
    if (U[$1])
      error("Input tree error: duplicate '" $1 "' in column 1")
    
    U[$1] = $2
    Nd[$2]++
    # daughter order
    Do[$2][Nd[$2]] = $1
  }
  close(DIR "/" FILEBASE ".fy")

  # find root
  for (i in Nd)
    if (!U[i]) {
      if (!Root)
        Root = i
      else
        error("Two roots = disconnected trees; '" i "' vs '" Root "'")
    }
  # print "Root: " Root
  
  # THIS IS KEY - never realized this before!!
  delete U[Root]
  
  # find tips
  for (i in U)
    if (!Nd[i]) {
      Tip[i] = 1
      delete Nd[i]
    }
  
  # print "Tips: "
  # for (i in U)
  #   if (Tip[i])
  #     print "  " i

  system("rm " DIR "/error >& /dev/null")
}

function test_args() {
  
  # test for unitary arguments
  for (i = 2; i < ARGC; i++)
    if (split(ARGV[i], tmp, " ") > 1)
      error("arguments must be single words: '" ARGV[i] "'")
}

function add_node(node, new) {

  test_node_is_in(node)
  test_node_is_out(new)
  # U array
  U[new] = node
  # Nd array
  Nd[U[new]]++
  # Do array - add as last
  Do[U[new]][Nd[U[new]]] = new
  # Tip array
  Tip[new] = 1
  # tricky! this fails: it creates Tip[node] to check it, but it's value is ""
  # if (Tip[node])
  #   delete Tip[node]
  delete Tip[node]
}

function spin_node(node  , tmp) {
  
  test_node_is_in(node)
  
  # test for exactly two daughters
  if (Nd[node] != 2)
    error("spinning only possible with a bifurcating node")

  # only thing that need to change is the ordering of Do
  tmp = Do[node][1]
  Do[node][1] = Do[node][2]
  Do[node][2] = tmp

}


function insert_node(node, new, i) {

  test_node_is_in(node)
  test_node_is_out(new)

  if (node == Root)
    error("Cannot insert at root")

  # U array
  U[new] = U[node]
  U[node] = new
  
  # Nd array: parent Nd not changed, but self:
  Nd[new] = 1

  # Do array
  # self
  Do[new][1] = node
  # parent 
  for (i = 1; i <= Nd[U[new]]; i++)
    if (Do[U[new]][i] == node)
      Do[U[new]][i] = new
}

function rm_node(node    , i, daughter, parent) {
  
  test_node_is_in(node)

  # error if the node has more than one daughters
  if (Nd[node]>1)
    error("node '" node "' has more than one daughter")

  # fail if trying to delete root
  if ((node == Root) ||                         \
      ((U[node] == Root) && (Nd[Root] == 1)))
    error("Cannot delete root node")

  # set convenience variables
  daughter = Do[node][1]
  parent = U[node]

  # deleting a single-daughter node
  if (Nd[node] == 1) {
    
    # U array
    # find the daughter and give it a new parent
    U[daughter] = U[node]
    # delete self
    delete U[node]
    
    # Nd array, unchanged for parent, delete for self
    delete Nd[node]

    # Do array, adjust parent
    for (i = 1; i <= Nd[parent]; i++)
      if (Do[parent][i] == node)
        Do[parent][i] = daughter
    # delete for self
    delete Do[node]
    
  }
  # else the node is a tip
  else {
    # U array
    delete U[node]

    # Do array, need to delete and reorder!
    for (i = 1; i <= Nd[parent]; i++)
      if (Do[parent][i] != node) 
        newd[++j] = Do[parent][i]
    for (i = 1; i < Nd[parent]; i++)
      Do[parent][i] = newd[i]
    # now delete the final index
    delete Do[parent][Nd[parent]]
    
    # No Do for self, since tip
    
    # Nd array, parent has one less daughter
    Nd[parent]--
    # No Nd for self, since tip, BUT used for testing
    delete Nd[node]
    
    # if the parent had been a single node and is now a term
    if (!Nd[parent])
      Tip[parent] = 1
  }
}

function edit_label(old, new,  i, parent) {

  test_node_is_in(old)
  test_node_is_out(new)

  parent = U[old]
  
  # U array
  # fix label for daughters
  for (i in U) {
    if (U[i] == old)
      U[i] = new
  }
  # fix label for parent, unless node is root
  if (old != Root) {
    U[new] = parent
    delete U[old]
  }

  # if tip
  if (Tip[old]) {
    Tip[new]=1
    delete Tip[old]
    
    # Do array for parent
    for (i in Do[parent])
      if (Do[parent][i] == old)
        Do[parent][i] = new
  }
  else {
    # Do array for self
    for (i in Do[old])
      Do[new][i] = Do[old][i]
    delete Do[old]

    # Do array for parent
    for (i in Do[parent])
      if (Do[parent][i] == old)
        Do[parent][i] = new
    
    #Nd array
    Nd[new] = Nd[old]
    delete Nd[old]
    
    # Delete this test case index
    delete Tip[old]
  }
}
  
function make_jpg(   i, j, x) {
  
  print "graph phy {\n  rankdir = \"LR\" ;\n  size=\"10,10\";\n" \
    "  dpi=\"96\";" > (DIR "/" FILEBASE ".dot")

  # Root seperate - not a daughter
  if (Nd[Root] == 2)
    x = "spin,add,edit"
  else
    x = "add,edit"
  print "  \"" Root "\" [style=filled,URL=\"" APPNAME                   \
    "?node=" Root "&amp;actions=" x "&amp;file=" FILEBASE "\"];" >      \
    (DIR "/" FILEBASE ".dot")
  # all daughters, correctly ordered
  for (i in Do)
    for (j = 1; j<=Nd[i]; j++) {
      # tips
      if (Nd[Do[i][j]] <= 1)
        x = "rm,insert,add,edit"
      else if (Nd[Do[i][j]] == 2)
        x = "spin,insert,add,edit"
      else 
        x = "insert,add,edit"
      
      print "  \"" Do[i][j] "\" [URL=\"" APPNAME "?node=" Do[i][j]   \
        "&amp;actions=" x "&amp;file=" FILEBASE "\"];" >             \
        (DIR "/" FILEBASE ".dot")
    }
  
  for (i in U)
    print "  \"" U[i] "\" -- \"" i "\" ;" > (DIR "/" FILEBASE ".dot")

  print "  { rank=same ;" > (DIR "/" FILEBASE ".dot")
  for (i in U)
    if (Tip[i])
      print "    \"" i "\" ;" > (DIR "/" FILEBASE ".dot")
  print "  }\n}" > (DIR "/" FILEBASE ".dot")
  close(DIR "/" FILEBASE ".dot")
  
  system("./dot -Tcmapx -o" (DIR "/" FILEBASE ".map") " -Tjpg -o"   \
         (DIR "/" FILEBASE ".jpg") " " (DIR "/" FILEBASE ".dot"))
}

function write_phy () {
  for (i in Do)
    for (j = 1; j<=Nd[i]; j++)
      print Do[i][j], i > (DIR "/" FILEBASE ".fy")
}

function error(msg) {
  print msg > (DIR "/error")
  print "Error: " msg > "/dev/stderr" 
  exit 1
}

function debug(msg,     i, j) {
  print " ===================== " msg " =========================== "
  print "File: " DIR "/" FILEBASE ".fy"
  system("cat " DIR "/" FILEBASE ".fy")
  
  print "\ni, U[i]"
  for (i in U)
    print i, U[i]

  print "\ni, Nd[i]"
  for (i in Nd)
    print i, Nd[i]

  print "\ni, j, Do[i][j]"
  for (i in Do)
    for (j = 1; j <= Nd[i]; j++)
      print i, j, Do[i][j]

  print "\ni, Tip[i]"
  for (i in Tip)
    print i, Tip[i]

}
