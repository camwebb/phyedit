#!/usr/bin/gawk -f

BEGIN{
  
  APPNAME ="do"
  DEBUG = 1
  
  load()
  test_args()

  if(DEBUG) {
    print "File: " DIR "/" FILEBASE ".fy"
    system("cat " DIR "/" FILEBASE ".fy")
    debug("pre-action")
  }
  
  if ((ARGC == 4) && (ARGV[1] == "add"))
    add_node(ARGV[2], ARGV[3])
  if ((ARGC == 4) && (ARGV[1] == "insert"))
    insert_node(ARGV[2], ARGV[3])
  if ((ARGC == 3) && (ARGV[1] == "spin"))
    spin_node(ARGV[2])
  if ((ARGC == 3) && (ARGV[1] == "rm"))
    rm_node(ARGV[2])
  if ((ARGC == 4) && (ARGV[1] == "edit"))
    edit_label(ARGV[2], ARGV[3])

  if(DEBUG)
    debug("post-action")
  
  make_jpg()

  if(DEBUG)
    debug("final")

  write_phy()
  
  exit 0
}


function load(   i, nd) {

  FS=OFS="|"
  PROCINFO["sorted_in"] = "@ind_str_asc"

  if(ENVIRON["PHYEDIT_FILEBASE"])
    FILEBASE = ENVIRON["PHYEDIT_FILEBASE"]
  else
    FILEBASE = "phy"

  if(ENVIRON["PHYEDIT_DIR"])
    DIR = ENVIRON["PHYEDIT_DIR"]
  else
    DIR = "."
  
  if (system("test -f " DIR "/" FILEBASE ".fy" ))
    error("'" DIR "/" FILEBASE ".fy' is not a file")
  
  # read tree
  while ((getline < (DIR "/" FILEBASE ".fy")) > 0) {
    if (U[$1])
      error("Input tree error: duplicate '" $1 "' in column 1")
    
    U[$1] = $2
    #/ Nd[$2]++
    # daughter order
    D[$2][++nd[$2]] = $1
  }
  close(DIR "/" FILEBASE ".fy")

  # find root
  for (i in D)
    if (!U[i]) {
      if (!Root)
        Root = i
      else
        error("Two roots = disconnected trees; '" i "' vs '" Root "'")
    }
  # print "Root: " Root
  
  # THIS IS KEY - never realized this before!!
  #/ delete U[Root]
  # NOTE U[Root] now exists but is "" -- no problem
  
  #/ # find tips
  #/ for (i in U)
  #/   if (!Nd[i]) {
  #/     Tip[i] = 1
  #/     delete Nd[i]
  #/   }
  
  # print "Tips: "
  # for (i in U)
  #   if (Tip[i])
  #     print "  " i

  system("rm " DIR "/error >& /dev/null")
}

function add_node(node, new) {

  test_node_is_in(node)
  test_node_is_out(new)
  # U array
  U[new] = node
  # Nd array
  #/ Nd[U[new]]++
  # D array - add as last
  D[node][length(D[node])+1] = new
  # Tip array
  #/ Tip[new] = 1
  # tricky! this fails: it creates Tip[node] to check it, but it's value is ""
  # if (Tip[node])
  #   delete Tip[node]
  #/ delete Tip[node]
}

function spin_node(node  , tmp) {
  
  test_node_is_in(node)
  
  # test for exactly two daughters
  if (Nd[node] != 2)
    error("spinning only possible with a bifurcating node")

  # only thing that need to change is the ordering of D
  tmp = D[node][1]
  D[node][1] = D[node][2]
  D[node][2] = tmp

}


function insert_node(node, new, i) {

  test_node_is_in(node)
  test_node_is_out(new)

  if (node == Root)
    error("Cannot insert at root")

  # U array
  U[new] = U[node]
  U[node] = new
  
  # Nd array: parent Nd not changed, but self:
  Nd[new] = 1

  # D array
  # self
  D[new][1] = node
  # parent 
  for (i = 1; i <= Nd[U[new]]; i++)
    if (D[U[new]][i] == node)
      D[U[new]][i] = new
}

function rm_node(node    , i, daughter, parent) {
  
  test_node_is_in(node)

  # error if the node has more than one daughters
  if (Nd[node]>1)
    error("node '" node "' has more than one daughter")

  # fail if trying to delete root
  if ((node == Root) ||                         \
      ((U[node] == Root) && (Nd[Root] == 1)))
    error("Cannot delete root node")

  # set convenience variables
  daughter = D[node][1]
  parent = U[node]

  # deleting a single-daughter node
  if (Nd[node] == 1) {
    
    # U array
    # find the daughter and give it a new parent
    U[daughter] = U[node]
    # delete self
    delete U[node]
    
    # Nd array, unchanged for parent, delete for self
    delete Nd[node]

    # D array, adjust parent
    for (i = 1; i <= Nd[parent]; i++)
      if (D[parent][i] == node)
        D[parent][i] = daughter
    # delete for self
    delete D[node]
    
  }
  # else the node is a tip
  else {
    # U array
    delete U[node]

    # D array, need to delete and reorder!
    for (i = 1; i <= Nd[parent]; i++)
      if (D[parent][i] != node) 
        newd[++j] = D[parent][i]
    for (i = 1; i < Nd[parent]; i++)
      D[parent][i] = newd[i]
    # now delete the final index
    delete D[parent][Nd[parent]]
    
    # No D for self, since tip
    
    # Nd array, parent has one less daughter
    Nd[parent]--
    # No Nd for self, since tip, BUT used for testing
    delete Nd[node]
    
    # if the parent had been a single node and is now a term
    if (!Nd[parent])
      Tip[parent] = 1
  }
}

function edit_label(old, new,  i, parent) {

  test_node_is_in(old)
  test_node_is_out(new)

  parent = U[old]
  
  # U array
  # fix label for daughters
  for (i in U) {
    if (U[i] == old)
      U[i] = new
  }
  # fix label for parent, unless node is root
  if (old != Root) {
    U[new] = parent
    delete U[old]
  }

  # if tip
  if (Tip[old]) {
    Tip[new]=1
    delete Tip[old]
    
    # D array for parent
    for (i in D[parent])
      if (D[parent][i] == old)
        D[parent][i] = new
  }
  else {
    # D array for self
    for (i in D[old])
      D[new][i] = D[old][i]
    delete D[old]

    # D array for parent
    for (i in D[parent])
      if (D[parent][i] == old)
        D[parent][i] = new
    
    #Nd array
    Nd[new] = Nd[old]
    delete Nd[old]
    
    # Delete this test case index
    delete Tip[old]
  }
}
  
function make_jpg(   i, j, x) {
  
  print "graph phy {\n  rankdir = \"LR\" ;\n  size=\"10,10\";\n" \
    "  dpi=\"96\";" > (DIR "/" FILEBASE ".dot")

  # Root seperate - not a daughter
  if (length(D[Root]) == 2)
    x = "spin,add,edit"
  else
    x = "add,edit"
  print "  \"" Root "\" [style=filled,URL=\"" APPNAME                   \
    "?node=" Root "&amp;actions=" x "&amp;file=" FILEBASE "\"];" >      \
    (DIR "/" FILEBASE ".dot")
  # all daughters, correctly ordered
  for (i in D)
    for (j = 1; j<=length(D[i]); j++) {
      # tips
      if (length(D[D[i][j]]) <= 1)
        x = "rm,insert,add,edit"
      else if (length(D[D[i][j]]) == 2)
        x = "spin,insert,add,edit"
      else 
        x = "insert,add,edit"
      
      print "  \"" D[i][j] "\" [URL=\"" APPNAME "?node=" D[i][j]   \
        "&amp;actions=" x "&amp;file=" FILEBASE "\"];" >             \
        (DIR "/" FILEBASE ".dot")
    }
  
  for (i in U)
    if (i != Root)
      print "  \"" U[i] "\" -- \"" i "\" ;" > (DIR "/" FILEBASE ".dot")

  print "  { rank=same ;" > (DIR "/" FILEBASE ".dot")
  for (i in D)
    if (!length(D[i]))
      print "    \"" i "\" ;" > (DIR "/" FILEBASE ".dot")
  print "  }\n}" > (DIR "/" FILEBASE ".dot")
  close(DIR "/" FILEBASE ".dot")
  
  system("./dot -Tcmapx -o" (DIR "/" FILEBASE ".map") " -Tjpg -o"   \
         (DIR "/" FILEBASE ".jpg") " " (DIR "/" FILEBASE ".dot"))
}

function write_phy () {
  for (i in D)
    for (j = 1; j<=length(D[i]); j++)
      print D[i][j], i > (DIR "/" FILEBASE ".fy")
}

function test_args() {
  
  # test for unitary arguments
  for (i = 2; i < ARGC; i++)
    if (split(ARGV[i], tmp, " ") > 1)
      error("arguments must be single words: '" ARGV[i] "'")

  # TODO: add other tests for allowable node names
  
}

function test_node_is_out(x)  {
  if (U[x] || (x == Root))
    error("'" x "' already in tree")
  
  # fix index, an entry for U[x] was created during test
  delete U[x]
}

function test_node_is_in(x)  {
  if (!U[x] && (x != Root))
    error("'" x "' is not in tree")

  #/ # fix index in case the root was used as a test
  #/ if (x == Root)
  #/   delete U[Root]
}

function error(msg) {
  print msg > (DIR "/error")
  print "Error: " msg > "/dev/stderr" 
  exit 1
}

function debug(msg,     i, j) {
  print " ===================== " msg " =========================== "
  
  print "\ni, U[i]"
  for (i in U)
    print i, U[i]

  #/ print "\ni, Nd[i]"
  #/ for (i in Nd)
  #/   print i, Nd[i]

  print "\ni, j, D[i][j]"
  for (i in D)
    for (j = 1; j <= length(D[i]); j++)
      print i, j, D[i][j]

  #/ print "\ni, Tip[i]"
  #/ for (i in Tip)
  #/   print i, Tip[i]

}

# function fy2new(                 x , y, n, first , mark, tmp)  {
#   # history: phylomatic 2011 -> here (modified)

#   # fy2new (recursive version)
#   # converts a tabular fy format phylogeny to Newick, parenthetical format

#   # fy-format = tab-delimited string fields:
#   #   1. nodeID
#   #   2. Parent node nodeID (must be either "-1", "", or "NULL" for
#   #      root node)
#   #   3. branch length to Parent node (an integer or float; missing for no BLs)
#   #   4. node name (terminal or interior node)
#   #   5. (optional) notes attached node

#   # check for RootNode:
#   if (RootNode == "")
#     error("No RootNode found")

#   # lDaughter, rSister needed for down-pass recursivity. Create:

#   # initialize
#   for (x in Parent) {
#     lDaughter[x] = "NULL"
#     rSister[x] = "NULL"
#     first[x] = 1
#     n++
#   }

#   # special case of a single node:
#   if (n == 1) {
#     print Taxon[x] ";"
#     return
#   }

#   # create lDaughter, rSister
#   for (x in Parent) {
#     # starting at terms
#     if (!DaughtersN[x]) {
#       y = x
#       # while not yet at the RootNode (allow diff coding schemes)
#       while (y != RootNode) {
#         # is this the first daughter?
#         if (lDaughter[Parent[y]] == "NULL")
#           lDaughter[Parent[y]] = y
#         # if not, find the dangling sister
#         else {
#           # start at lDaughter
#           mark = lDaughter[Parent[y]]
#           # move to node with an empty rSister
#           while (rSister[mark] != "NULL")
#             mark = rSister[mark]
#           rSister[mark] = y
#         }
        
#         # test for refollowing old routes
#         if (first[Parent[y]] == 1) {
#           y = Parent[y]
#           first[y] = 0
#         }
#         else
#           break
#       }
#     }
#   }

#   # Now recurse through levels, creating out string in tmp

#   tmp = ""
  
#   print downPar(RootNode, tmp) ";"
  
#   if (Warning)
#     print Warning > "/dev/stderr"
# }

# function downPar(atn, tmp,           x, which, tmpnext ) {
#   which = 0

#   # if terminal, go no further
#   if (!DaughtersN[atn]) {
#     tmp = gensub(/ /,"_","G",Taxon[atn])
#     if ((HasBL) && ( Bl[atn])) 
#       tmp = tmp ":" Bl[atn]
#     if (Note[atn])
#       # TODO: escape any [, ] in note 
#       tmp = tmp "[" Note[atn] "]" 
#   }
#   else {
    
#     x = lDaughter[atn]
#     tmp =  "("
#     tmp = tmp downPar(x, tmpnext[which])
    
#     x = rSister[x]; which++
    
#     while (x != "NULL") {
#       tmp = tmp  ","
#       tmp = tmp downPar(x, tmpnext[which])
#       x = rSister[x]; which++
#     }
#     tmp = tmp  ")"
#     tmp = tmp  gensub(/ /,"_","G",Taxon[atn])
    
#     if ((HasBL) && ( Bl[atn])) 
#       tmp = tmp  ":" Bl[atn]
#     if (Note[atn])
#       tmp = tmp "[" Note[atn] "]" 
#   }
  
#   return tmp
# }
